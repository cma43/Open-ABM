##############################################################################################################################
#FIXME: Either have MESA examples as a part of OABM or find a way to pull examples 
#for users when they want to use a MESA example env in a way like below:

# from git import Repo

# git_url = 'https://github.com/projectmesa/mesa/tree/master/examples'
# repo_dir = 'C:\\Users\\conar\\Documents\\GitHub\\ABM\\Examples\\OpenABM\\OABM_test'
# Repo.clone_from(git_url, repo_dir)

#Some useful thoughts from https://stackoverflow.com/questions/8718885/import-module-from-string-variable

#TODO: It would be nice to have a method that spits out attributes, and commented descriptions along with them
#TODO: unit tests

##############################################################################################################################
import numpy as np
import sys
import os 
import importlib
from pydoc import locate
import inspect
from collections import defaultdict
from mesa.datacollection import DataCollector
import types 

#from examples.bank_reserves.bank_reserves import  agents, model, random_walk, server 

env_id = {'Conway-GOL': ('conways_game_of_life', 'ConwaysGameOfLife'), 
          'Boid-Flockers': ('boid_flockers', 'BoidFlockers'),
          'Bank-Reserves': ('bank_reserves', 'BankReserves'),
          'Boltzmann-Wealth': ('boltzmann_wealth_model', 'BoltzmannWealthModel'), 
          'Boltzmann-Wealth-Network':('boltzmann_wealth_model_network','BoltzmannWealthModelNetwork'),
          'Epstein-Civil-Violence': ('epstein_civil_violence', 'EpsteinCivilViolence'),
          'Forest-Fire': ('forest_fire', 'ForestFire'),
          'Hex-Snowflake': ('hex_snowflake', 'HexSnowflake'),
          'PD-Grid':('pd_grid', 'PdGrid'),
          'Schelling':('schelling', 'Schelling'),
          'Sugarscape': ('sugarscape_cg', 'SugarscapeCg'), 
          'Virus-On-Network': ('virus_on_network', 'VirusOnNetwork'),
           'Wolf-Sheep': ('wolf_sheep', 'WolfSheep'),
           'BWT (Currently Unavailable)': (), #TODO
           'Cartel (Currently Unavailable)': ()} #TODO

def check_models():

    """Returns the current list of available models one can plug-and-play with Open ABM

    :return: Returns a list of strings of valid names one can use with Open ABM's make() function for building models.
    :rtype: String

    """

    for name in env_id.keys():
        print(name)
    
    return

def make(model_name, server = True):

    """Makes a model instantiation of the requestion ABM, where the ABM name is a string taken from the list generated by check_models()

    :param model_name: String name of the model, as taken from check_models() output
    :type model_name: String

    :param server: Boolean-valued parameter. If true, a pop-out interactive window should appear in your browser for the default visualizations of the requested model.
    :type server: Boolean

    
    :raises AssertionError: model_name only accepts strings.
    

    :return: Returns an instance of the requested ABM

    """

    if not isinstance(model_name, str):
        raise AssertionError("The .make() method only accepts strings!")

    #TODO: Raise error if model_name is not in the pre-specified list of acceptable environment
    # names, and then print / suggest the list of names the user can choose from so they don't have
    # to schlep to the documentation.  

    if model_name in env_id:    

        try:
            env_name = env_id.get(model_name)[0]
        except:
            print("You either entered an incorrect name, or an environment that is currently not supported!")
        if not env_name:
            print("You either entered an incorrect name, or an environment that is currently not supported!")
       
        print("{} ABM imported, instantiating environment".format(model_name))  
        #Import and instantiate chosen ABM
        if model_name == 'Schelling':
            env = importlib.import_module('examples.{}.model'.format(env_name))
        else:
            env = importlib.import_module('examples.{}.{}.model'.format(env_name, env_name))

        env = getattr(env, env_id.get(model_name)[1])

        return env(server = server)

def export_data(model, agent_level, model_level):

    """Exports data associated with the datacollector attribute of a model instance.

    :param model: An instance of an Open ABM-supported model / environment
    
    :param agent_level: Tells export_data whether to return agent-level data
    :type agent_level: Boolean

    :param model_level: Tells export_data whether to return model-level data 
    :type model_level: Boolean

    
    :raises AssertionError: Model and agent must be Booleans, and must both be specified.
     

    :return: Dataset of model- and/or agent-level data depending on user input
    :rtype: Pandas Dataframe

    """

    #NOTE: currently returns list of two Pandas dataframes for agent and the model level data if both are true.
    if not isinstance(agent_level, bool):
        raise AssertionError("agent_level must be True or False")
    if not isinstance(model_level, bool):
        raise AssertionError('model_level must be True or False')

    if agent_level == True and model_level == False:
        data = export_agent_data(model)
    if model_level == True and agent_level == False:
        data = export_model_data(model)
    if agent_level == True and model_level == False:
        data = export_agent_data(model), export_model_data(model) 
    return data

def export_agent_data(model):

    """Helper function for export_data, but accessible to user if preferred.

    :param model: An Open ABM supported model / environment instance
    
    :return: Agent-level data
    :rtype: Pandas Dataframe

    """

    data = model.datacollector.get_agent_vars_dataframe()

    return data
        
def export_model_data(model):

    """Helper function for export_data, but accessible to user if preferred.

    :param model: An Open ABM supported model / environment instance
    
    :return: Model-level data
    :rtype: Pandas Dataframe
    """
    
    data = model.datacollector.get_model_vars_dataframe()

    return data

def get_model_parameters(model):

    """Returns the full dictionary of all model-level parameters / attributes.

    :param model: An Open ABM supported model / environment instance

    :return: Python dictionary of model-level parameters

    """

    return vars(model)

def set_model_parameters(model, new_params):

    """Adjusts the dictionary of model-level parameters / attributes.

    :param model: An Open ABM supported model / environment instance
    :param new_params: A python dictionary of parameters / attributes replacing old parameter values. 

    :return: A model instance

    """

    if isinstance(new_params, dict):
        for key in new_params.keys():
            if key in vars(model).keys():
                vars(model)[key] = new_params[key]
    else:
        print("new_params must be in the form of a Python dictionary!")

    return model

def get_agent_parameters(model):

    """Returns Python dictionary of all agents' model parameters.

    :param model: An Open ABM supported model / environment instance. 

    :return: Nested dictionary of each agent's dictionary of parameters/attributes.

    """


    #TODO: add ability to get values for particular param subsets from these params, as well as particular agents
    d = nested_dict()
    for i, agent in enumerate(model.schedule.agents):
        d[agent.unique_id] = vars(model.schedule.agents[i])
    return d

def nested_dict():
    """Helper function for creating nested dictionaries.

    """

    return defaultdict(nested_dict)

#TODO: data_dict method taking in unqiue IDs, or making dict of data by attribute 

def set_agent_parameters(model, new_params):

    """Takes a model object and uses the dictionary of new parameters to update agents' parameters.

    :param model: An Open ABM supported model /environment instance.

    :new_params: A python dictionary with unique IDs of agents as keys and dictionaries of new parameter values as values.

    :return: Returns an updated model object containing updated agent parameters.

    """

    #Assumes new_params takes the form of a nested dict for more than one agent change ;
    #Assumes keys are the desired unique IDs of agents

    if isinstance(new_params, dict) or isinstance(new_params, defaultdict):

        for uid in new_params.keys():
            for attr in new_params[uid]: 
                vars(model.schedule.agents[uid])[attr] = new_params[uid][attr] 


    return model 



def set_data_collection(model, agent_level, model_level, agent_data_to_collect = None, model_data_to_collect = None):

    """Sets the data to be collected by the model for agent and model leveld data.

    data_to_collect can be a dict of string_names the user chooses and then attributes the user wants, or
    it can be string_names the user chooses and functions of the model that the user wants 

    Note that if only specifying data collection for agent or model level, then data_to_collect automatically fills that slot;
    otherwise, user must specify separate dictionary

    Also note that this assumes that the given model has a datacollector attribute already!
    
   :param model: Open ABM supported model instance
   :param agent_level: Boolean specifying whether to collect agent level data
   :param model_level: Boolean specifying whether to collect model level data 

   :return: Updated instance of the model set to collect the requested data.

   """
   
    if agent_data_to_collect:
        assert(isinstance(agent_data_to_collect, dict))
    if model_data_to_collect:
        assert(isinstance(model_data_to_collect, dict))
        
    assert(isinstance(agent_level, bool))
    assert(isinstance(model_level, bool))

    if model_level == True and agent_level == False:
        if model.datacollector:
            model.datacollector = DataCollector(model_reporters= model_data_to_collect)
        else:
            print('Model must have a datacollector attribute which is an instance of MESA DataCollector class!')
    elif model_level == False and agent_level == True:

        if model.datacollector:
            model.datacollector = DataCollector(agent_reporters=agent_data_to_collect)
        
        else:
            print('Model must have a datacollector attribute which is an instance of MESA DataCollector class!')
    elif model_level == True and agent_level == True:
        if model.datacollector:
            model.datacollector = DataCollector(agent_reporters=agent_data_to_collect, model_reporters= model_data_to_collect)

        else:
            print('Model must have a datacollector attribute which is an instance of MESA DataCollector class!')

    elif model_level == False and agent_level == False:
        print('One or both of model_level and agent_level must be set to True or False to collect data, and you must provide agent and/or model level data to collect')

    else:
        print('model_level and agent_level must both be booleans!')


        
    if False:
        print("(agent/model)_data_to_collect must be in the form of a dictionary, agent_level must be a boolean, and model_level must be a boolean!")

    return model

###################################################################################################
#NOTE: once data collection is set, MESA already has methods to collect data into Pandas dataframes 
#TODO: unit tests!
###################################################################################################


def get_agent_step(agent_list, verbose = True, distinct = True):

    """Returns step functions of agents in a list.

    :param agent_list: A list of agents whose step functions we want to see
    :param verbose: Boolean specifying if the function should print each agent's step function
    :param distinct: Boolean. If true, then when verbose is True will print each agent's step function. If false with verbose set to true, will only print distinct step function per type of agent.

    :return: List of agent step functions in the form of individual Python dictionaries.

    """
    
    a_list = []

    #NOTE: based on solution posted here: https://stackoverflow.com/questions/54374296/extract-python-function-source-text-from-the-source-code-string
    #TODO: store agent unique ID with step function in a dict; 

    for _, agent in enumerate(agent_list):

        #TODO: this should probably just be a list comprehension 
        #TODO: throw error if not of agent type specified in model class that the agent belongs to
        
        lines = inspect.getsource(type(agent)).split('\n')

        #looking for lines with 'def' keywords
        defidxs = [e[0] for e in enumerate(lines) if 'def step(self):' in e[1]]

        #getting the indentation of each 'def'
        indents = {}
        for i in defidxs:
            ll = lines[i].split('def')
            indents[i] = len(ll[0])

        #extracting the strings
        end = len(lines)-1
        while end > 0:
            if end < defidxs[-1]:
                defidxs.pop()
            try:
                start = defidxs[-1]
            except IndexError: #break if there are no more 'def'
                break

            #empty lines between functions will cause an error, let's remove them
            if len(lines[end].strip()) == 0:
                end = end - 1
                continue

            try:
                #fix lines removing indentation or compile will not compile
                fixlines = [ll[indents[start]:] for ll in lines[start:end+1]] #remove indentation
                body = '\n'.join(fixlines)
                compile(body, '<string>', 'exec') #if it fails, throws an exception
                a_list.append((i, body))
                end = start #no need to parse less line if it succeed.

            except:
                pass

            end = end - 1        
        
        if verbose and distinct:
            #solution from: https://stackoverflow.com/questions/12897374/get-unique-values-from-a-list-in-python
            used = set()
            to_show = [a[1] for a in set(a_list)]
            unique_to_show = [x for x in to_show if x not in used and (used.add(x) or True)]
            for t in unique_to_show:
                print(t)
            return a_list
                    
        elif verbose and not distinct:
            for j, a in enumerate(a_list):
                print(a[1])
                print(type(agent_list[j]))
            return a_list


    return

def set_agent_step(agent_dict, model):

    """Set step functions based on a dict of unique IDs with associated new step function.
    
    :param agent_dict: Python dictionary of unique ID / step function keys/values
    :param model: Open ABM supported model instance

    :return: Updated model instance
    """
    #Currently just assumes all agents of interest (by UID) and their step functions are specified in a dict. Need to add functionality allowing user to 
    #specify a step function for all agents of a class, all agents in a subset of the same OR different class, or for all agents generally

    #**TODO: should work for specifying some class-specific type of agent, or a particular subset of agents by UID!************
    #TODO: UNIT TEST
    #TODO: check that agents work still after changing step function
    #return step functions of an agent list; if model is not none, then return step functions of all types of agent in model
    
    #TODO: Generalize this for the case where the only key in agent_dict is a list of agents for a single new step, and then for a list of agents with various
    #other step functions by UID or another identifier.
    
    for agent_id in agent_dict.keys():

        model.schedule.agents[agent_id].step = types.MethodType(agent_dict[agent_id], model.schedule.agents[agent_id])

    return model

def get_model_step(model, verbose = True):

    """Returns step functions of model instance.

    :param model: Open ABM supported model instance.
    :param verbose: Boolean specifying if the function should print step function

    :return: String of source code for the model's step function.

    """

    #NOTE: based on solution posted here: https://stackoverflow.com/questions/54374296/extract-python-function-source-text-from-the-source-code-string
    #TODO: throw error if not of agent type specified in model class that the agent belongs to
    #NOTE: assumes that there are only model or agent specific step functions in each agent or model module.

    lines = inspect.getsource(type(model)).split('\n')

    #looking for lines with 'def' keywords
    defidxs = [e[0] for e in enumerate(lines) if 'def step(self):' in e[1]]

    #getting the indentation of each 'def'
    indents = {}
    for i in defidxs:
        ll = lines[i].split('def')
        indents[i] = len(ll[0])

    #extracting the strings
    end = len(lines)-1
    while end > 0:
        if end < defidxs[-1]:
            defidxs.pop()
        try:
            start = defidxs[-1]
        except IndexError: #break if there are no more 'def'
            break

        #empty lines between functions will cause an error, let's remove them
        if len(lines[end].strip()) == 0:
            end = end - 1
            continue

        try:
            #fix lines removing indentation or compile will not compile
            fixlines = [ll[indents[start]:] for ll in lines[start:end+1]] #remove indentation
            body = '\n'.join(fixlines)
            compile(body, '<string>', 'exec') #if it fails, throws an exception
            end = start #no need to parse less line if it succeed.

        except:
            pass

        end = end - 1        
        
        if verbose:
            print(body)
            print(type(model))
            return body
        else: 
            return body

def set_model_step(model, new_step_func):

    """Sets step function for the model, and returns the updated model instance.

    :param model: An Open ABM supported model instance.
    :param new_step_func: A method acting as the new step function for the model.

    :return: An updated model instance.

    """

    #NOTE: must pass a model instance to refer to
    #TODO: check that model step function still works after changing it 
    #TODO: UNIT TESTS
    model.step = types.MethodType(new_step_func, model)
    
    return model

#TODO: Make server adjustments easy to do for the 13 examples; want to adjust the knobs we can tune that pop out,
#then want tools for just constructing a pop-out easier 

#TODO: may want to return data collection after watching sim in server pop-out 
        
        

